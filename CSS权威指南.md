### <center>CSS权威指南笔记</center> ###
>1. CSS和文档  
>   层叠样式表(CSS)的功能非常强大，可以影响一个或一组文档的表现  
>   如果不存在某种文档，CSS基本上毫无用处。  
>   >* CSS的出现  
>   >   HTML只是作为一种结构化标记语言，用于描述文档的各个部分，而对于这些部分应当如何显示则很少谈及。但是随着网页的发展，就出现了一些样式上的需求，如文本的粗体和斜体等。  
>   >   迫于压力，就出现了一些FONT和BIG之类的标记元素。   
>   >   但是这样大量的使用没有任何含义的标记，会使文档的可用性降低。如搜索的困难，维护困难等。  
>   >* CSS作救星  
>   >   1. 丰富的样式  
>   >   >   CSS可以为任何元素的文本和背景设置颜色；允许在任何元素外围创建边框等。
>   >   2. 易于使用  
>   >   >   样式表将实现某些视觉效果的命令集中在一个方便的位置，而不是在文档中分散得到处都是。  
>   >   >   这样进行样式的统一修改和几个元素使用同一个样式都很方便。
>   >   3. 在多个页面上使用样式  
>   >   >   不仅能把一个页面的所有样式信息集中到一个位置，还可以创建一个样式表，然后把这个样式表应用到多个页面。既将样式表单独保存为一个文档，然后由要使用该文档的页面导入。  
>   >   4. 层叠  
>   >   >   CSS规定了冲突规则：这些规则统称为层叠。  
>   >* 元素  
>   >   元素是文档结构的基础。
>   >   1. 替换和非替换元素   
>   >   >* 替换元素  
>   >   >   替换元素是指用来替换元素内容的部分并非由文档内容直接表示。如img元素，这个标记不包含任何具体内容，只有一个元素名和一个属性。除非将其指向一个外部内容(这里就是src指向的图像),否则这个元素没有任何意义。input元素类似，取决于input的类型，要由一个单选框、复选框或文本输入框替换。  
>   >   >* 非替换元素  
>   >   >   大多数HTML和XHTML元素都是非替换元素。这意味着，其内容由用户代理(通常是一个浏览器)在元素本身生成的框中显示。如span元素。  
>   >   2. 元素显示角色  
>   >   >* 块级元素  
>   >   >   块级元素生成一个元素框，它会填充其父元素的内容区，傍边不能有其他元素。如p和div标签。  
>   >   >* 行内元素  
>   >   >   行内元素在一个文本行内生成元素框，而不会打断这行文本。行内元素最好的例子就是XHTML中的a元素。  
>   >   >   在HTML和XHTML中，块级元素不能继承自行内元素(即不能嵌套在行内元素中)。但是在CSS中显示角色如何嵌套不存在任何限制。如:
>   >   >   ``` html  
>   >   >   <body>
>   >   >       <p>This is a paragraph whit <em>an inline element</em> with in it.</p>
>   >   >   </body>
>   >   >   <!-- css没有这种限制，可以改变两个元素的显示角色-->
>   >   >   p{dispaly:inline}
>   >   >   em{display:block}
>   >   >   <body>
>   >   >       <!-- 这种行内元素中嵌套块级元素是不合法的-->
>   >   >       <em><p>This is a paragraph improperly enclosed by an inline element.</p></em>
>   >   >   </body>
>   >   >   
>   >   >   ```  
>   >* 结合CSS和XHTML  
>   >   CSS和文档关联的多种方式  
>   >   1. link标记  
>   >   >   其基本目的是允许HTML创作人员将包含link标记的文档与其他文档相关联。CSS使用这个标记来链接样式表和文档。  
>   >   >   为了成功地加载一个外部样式表，link必须放在head元素中，但不能放在其他元素内部。  
>   >   >   外部样式表只是一个规则列表，规则会保存到其自己的文件中。但是样式表中不能包含XHTML或任何其他标记语言，只能有样式规则。如果一个外部样式表中出现标记，会导致其中一部分或全部被忽略。
>   >   >* 属性
>   >   >   rel属性代表关系，一般关系为stylesheet。type属性为加载的数据类型，一般类型为text/css。这些设置后就可以确定浏览器如何处理其导入的数据。href属性是样式表的URL。最后是media属性，值all表示这个样式表要应用于所有表现媒体，另外得到最广泛支持的类型是all、screen和print，可以将多个媒体值组合在一起作为media的值。  
>   >   >* 候选样式表(alternate style sheet)  
>   >   >   将rel属性的值设置为alternate stylesheet，就可以定义候选样式表，只有在用户选择这个样式表时才会用于文档表现。并且如果浏览器支持候选样式表，那么浏览器就会根据link的title属性生成选择列表。 当没有title时就无法显示在列表中，同时可以设置相同的title值为候选样式表进行分组。 
>   >   2. style元素  
>   >   >   可以使用style元素包含样式表，它在文档中单独出现:  
>   >   >   ``` html 
>   >   >   <style type="text/css"></style>
>   >   >   ```
>   >   >   也可以为style元素添加media属性。  
>   >   >   style元素内添加的样式称为文档样式表或嵌套样式表，并且其中可能包含应用到文档的多个样式，还可以使用@import指令包含多个外部样式表链接。  
>   >   3. @import指令  
>   >   >   ``` html  
>   >   >   @import url(sheet.css) all;  
>   >   >   ```
>   >   >   不同于link标签每个@import都会使用，因为@import无法指定候选样式表。  
>   >   >   并且@import指令应该出现在样式表的开头，即应该出现在样式表的其他规则之前，否则会将其忽略掉。  
>   >   4. 内联样式  
>   >   >   如果只是想为单个元素指定一些样式，而不需要嵌套或外部样式表，就可以使用HTML的Style属性来设置一个内联样式(inline style)。  
>   >   >   除了在body外部出现的标记，style属性可以与任何其他HTML标记关联。  
>   >   >   style属性的值是一个声明块，而不能是整个样式表。  
>2. 选择器  
>   CSS的核心是能向文档中的一组元素类型应用某些规则。  
>   >* 规则的结构  
>   >   每个规则都由两个基本的部分:选择器(selector)和声明块(declaration block)。声明块由多个声明组成，每个声明则以一个属性-值对组成。每个样式表由多个规则组成。  
>   >   选择器:定义了将影响文档中的哪些部分。  
>   >   声明块:多个声明组合表示选择器对应的元素应该怎样显示。   
>   >* 元素选择器  
>   >   最常见的选择器往往是HTML元素，但也不完全是这样。也有可能是XML文档的样式。  
>   >   文档的元素就是最基本的选择器，在XML中可以创建新的标记，所以什么都有可能作为选择器。  
>   >* 声明和关键字  
>   >   声明的格式一般是一个属性名+":"+值+";"。几乎在所有的情况下，值要么是一个关键字，要么就是关键字的列表，关键字之间用空格分隔。   
>   >* 分组  
>   >   如果想为多个元素应用同一个样式怎么做呢  
>   >   >1. 选择器分组   
>   >   >   将两个选择器放在规则的左边并用一个逗号来分隔，这样就定义了一个规则，其右边的样式将应用到这两个选择器所引用的元素。  
>   >   >   通配选择器:使用"*"号表示选择器，这个选择器可以和任何元素匹配。  
>   >   >2. 声明分组  
>   >   >   将多个声明使用分号分隔放在同一个声明块中。  
>   >   >3. 选择器分组和声明分组结合  
>   >* 类选择器(class selector)和ID选择器(ID selector)  
>   >   可以以一种独立于文档元素的方式来指定样式，不过需要适当地标记文档后才能使用这些选择器。   
>   >   >1. 类选择器  
>   >   >   要应用样式而不考虑具体涉及的元素，最常用的方法就是使用类选择器。在使用类选择器之前需要使用class属性进行文档标记。  
>   >   >   *.warning{}//与通配选择器结合的类选择器，可以省略通配符"*"  
>   >   >   p.warning{}//与元素选择器结合的类选择器  
>   >   >   p.warning.help//是一个多类选择器，对应class="warning help"  
>   >   >2. ID选择器  
>   >   >   在某些方法，ID选择器类似于类选择器，不过也有一些重要的差别。ID选择器前面有一个#号。  
>   >   >   *#first-para{}//可以省略通配符。  
>   >   >   与类选择器不同，一个HTML文档中，ID选择器会使用一次，而且仅一次。并且ID选择器不能结合使用，因为ID属性不允许有以空格分隔的词列表。  
>   >   >   并且类选择器和ID选择器是区分大小写的，因为文档将类和ID值定义为区分大小写。  
>   >   >3. 属性选择器  
>   >   >   对于类选择器和ID选择器，你所做的只是选择属性值。但是在一些非HTML、SVG和MathML文档的标记语言中，不能使用这些类和ID选择器。所以CSS2引入了属性选择器(attribute selector)。它可以根据元素的属性及属性值来选择元素。
>   >   >   * 简单属性选择器  
>   >   >   >   只是选择有某个属性的元素，而不论该属性的值是什么，可以使用一个简单属性选择器。如：
>   >   >   >   h1[class]{}//有class属性(值不限)的所有h1元素。
>   >   >   >   *[title]{}//所有带有title属性的元素  
>   >   >   >   a[href][title]//所有带有href和title属性的a元素  
>   >   >   * 具体属性值选择  
>   >   >   >   除了选择有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。  
>   >   >   >   a[href="http://XXX.com"]{}//href属性值为http://XXX.com的a元素。  
>   >   >   >   也可以多个联合使用，另外这个值的匹配是完全匹配。  
>   >   >   * 根据部分属性值选择
>   >   >   >   [foo~="bar"]//选择属性值中包含独立单词bar的所有元素  
>   >   >   >   [foo^="bar"]//选择属性值以"bar"结尾的所有元素  
>   >   >   >   [foo$="bar"]//选择属性值以"bar"开头的所有元素  
>   >   >   >   [foo*="bar"]//选择属性值中包含子串"bar"的所有元素  
>   >   >   * 特性属性选择类型  
>   >   >   >   [lang|=en]//选择lang属性为"en"或"en-"开头的所有元素。单词完成或以"-"分隔。  
>   >   >4. 后代选择器(descendant selector)  
>   >   >   后代选择器也称为包含选择器或上下文选择器。定义后代选择器就是来创建一些规则，它们仅在某些结构中其作用，而在另外一些结构中不起作用。如:
>   >   >   h1 em{}//只对h1的后代em元素应用样式  
>   >   >   在一个后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。  
>   >   >5. 选择子元素  
>   >   >   在某些情况下，可能并不想选择一个任意的后代元素；而是希望缩小范围，只选择另一个元素的子元素。例如：
>   >   >   h1>strong{}//>为子结合符，表示h1元素子元素的strong元素。  
>   >   >6. 选择相邻兄弟元素  
>   >   >   假设你希望对一个标题后紧接着的段落应用样式，或者像一个段落后紧接着的列表指定特殊的外边距。要选择紧接在另一个元素后的元素，而且两者有相同的父元素，可以使用相邻兄弟结合符(adjacentsibling combinator),这表示为一个(+)号。如：  
>   >   >   h1 + p {}//选择h1元素所有的p兄弟元素。  
>   >   >   并且CSS要求两个元素按"源顺序"出现。  
>   >   >7. 伪类和伪元素  
>   >   >   利用这些选择器，可以为文档中不一定具体存在的结构指定样式，或者为某些元素的状态所指示的幻想类指定样式。  
>   >   >   * 伪类选择器  
>   >   >   >   如锚元素有两个类型，已访问和未访问的。这些类型称为伪类(pseudo-class)，使用这些伪类的选择器称为伪类选择器。如:
>   >   >   >   a:visited{}//已访问的锚元素
>   >   >   >* 链接伪类  
>   >   >   >   a:link{}//选择未访问的有href属性的a元素  
>   >   >   >   a:visited{}//选择已访问的a元素  
>   >   >   >* 动态伪类  
>   >   >   >   link和visited两个是静态伪类，即第一次显示之后，它们一般不会再改变文档的样式。  
>   >   >   >   还有一些可以根据用户行为改变文档外观的伪类，主要有下面三种动态伪类:  
>   >   >   >   :focus//指示当前拥有输入焦点的元素。  
>   >   >   >   :hover//指示鼠标指针停留在哪个元素上。  
>   >   >   >   :active//指示被用户输入激活的元素。  
>   >   >   >   input:focus{}//为拥有输入焦点的input元素设置样式  
>   >   >   >* 选择第一个子元素  
>   >   >   >   还可以使用另一个静态伪类:first-child来选择元素的第一个子元素。  
>   >   >   >   p:first-child{}//选择所有作为第一个子元素的p元素。  
>   >   >   >   并不是选择p元素的第一个子元素，因为伪类的实质是把某种幻想类关联到与伪类相关的元素。  
>   >   >   >* 根据语言选择  
>   >   >   >   有些情况下，你可能想根据元素的语言来选择。则可以使用:lang伪类，从对应模式来讲，:lang伪类就像|=属性选择器。  
>   >   >   >* 结合伪类  
>   >   >   >   a:link:hover{}//鼠标停留在未访问的超链接上时，两个换前后顺序也没有影响  
>   >   >   >   a:visited:hover{}//鼠标停留在已访问的超链接上时。  
>   >   >   >   但是不能将互斥的伪类进行结合，如a:link:visited。一般都会被忽略。  
>   >   >* 伪元素选择器  
>   >   >   就像伪类为锚指定幻想类一样，伪元素能够在文档中插入假象的元素，从而得到某种效果。  
>   >   >   CSS2.1中定义了4个伪元素:设置首字母样式、设置第一行样式、设置之前和之后的样式。  
>   >   >   >* 设置首字母样式  
>   >   >   >   用于设置一个块级元素首字母的样式，而且仅对该首字母设置样式。  
>   >   >   >   p:first-letter{}//将每个p元素的第一个字母设置样式。  
>   >   >   >   其假想的元素如下:
>   >   >   >   ``` html  
>   >   >   >   <p><p:first-letter>T</p:first-letter>his is an p element</p>  
>   >   >   >   ```  
>   >   >   >* 设置第一行的样式  
>   >   >   >   p:first-line{}//可以用来影响元素中第一个文本行。  
>   >   >   >   对于:first-letter和:first-line伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等行内元素。后来在CSS2.1中:first-letter能应用到所有元素。但是两者的CSS属性还是有一些限制。并且所有伪元素应该放在选择器的最后面。  
>   >   >   >* 设置之前和之后元素的样式  
>   >   >   >   h2:before{content:"}}";color:silver}//在每个h2元素前添加内容  
>   >   >   >   h2:after{content:"}}";color:silver}//在每个h2元素后面添加内容  
>3. 结构和层叠  
>   >   有了结构树，选择器才能起作用，这也是CSS另一个重要方面(继承)的核心。  
>   >   继承是从一个元素向其后代元素传递属性值所采用的机制。确定应当向一个元素应用哪些值时，用户代理不仅要考虑继承，还要考虑声明的特殊性，另外需要考虑声明本身的来源。这个过程就是层叠。  
>   >   >* 特殊性  
>   >   >   之前介绍了多种不同的方法选择元素。所以可能同一个元素可以使用两个或多个规则来选择，每个规则都有其自己的选择器。如:  
>   >   >   h1 {color:red}
>   >   >   body h1{color:green}
>   >   >   
>   >   >   h2.grape{color:purple}
>   >   >   h2{color:silver}
>   >   >   
>   >   >   html>body table tr[id="totals"] td ul>li{color:maroon;}
>   >   >   li#answer{color:navy;}
>   >   >   对于这三对规则，每一对规则肯定只能有一个规则胜出，那么哪一个规则更强呢？  
>   >   >   这时就在于每个选择器的特殊性，对于每个规则，用户代理会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明。如果有元素存在冲突的属性声明，那么有最高特殊性的声明就会胜出。  
>   >   >   特殊性值表述为4个部分，如:0,0,0,0。具体如下：
>   >   >   <ul>
>   >   >       <li>对于选择器中给定的各个ID属性值，加0,1,0,0</li>
>   >   >       <li>对于选择器中给定的各个类属性值、属性选择或伪类，加0,0,1,0</li>
>   >   >       <li>对于选择器中给定的各个元素和伪元素，加0,0,0,1</li>
>   >   >       <li>结合符和通配选择器对特殊性没有贡献</li>
>   >   >   </ul>  
>   >   >* 声明和特殊性  
>   >   >   一旦确定一个选择器的特殊性，这个值将授予其所有相关声明。  
>   >   >* 通配选择器特殊性  
>   >   >   通配选择器对一个选择器的特殊性没有贡献。其特殊性为0,0,0,0，这与根本没有特殊性有区别。   
>   >   >   而结合符则根本没有特殊性，甚至连0特殊性都没有。  
>   >   >* ID和属性选择器的特殊性    
>   >   >   因为ID选择器和属性选择器对特殊性的贡献分别为0,1,0,0和0,0,1,0。所以如下:
>   >   >   #meadow{}//0,1,0,0   
>   >   >   *[id="meadow"]{}//0,0,1,0  
>   >   >   尽管都是选择ID为meadow的元素，然而其特殊性不相同。  
>   >   >* 内联样式特殊性       
>   >   >   之前见过的特殊性都是以0开头的特殊性，一般，第一个0是为内联样式声明保留的，它比所有其他声明的特殊性都高，为1,0,0,0。  
>   >   >* 重要性    
>   >   >   有时某个声明可能非常重要，超过了所有其他声明。CSS2.1称之为重要声明，并允许 在这些声明的结束分号之前插入!important来标志。如：
>   >   >   p.light{color:yellow;font:smaller Times,serif !important}    
>   >   >   重要声明和非重要声明要分开考虑，重要声明的特殊性冲突会在重要声明内部解决，而不会与非重要声明混淆。但是一个重要声明和一个非重要声明冲突，胜出的总是重要声明。  
>   >   >* 继承  
>   >   >   特殊性对于理解如何向文档应用声明很重要，同样的，还有一个很重要的概念，即继承。  
>   >   >   基于继承机制，样式不仅应用到指定的元素，还会应用到它的后代元素。例如，如果向一个h1元素应用一个颜色，那么这个颜色将应用到h1中的所有文本，甚至应用到该h1的子元素中的文本。  
>   >   >   有些属性不能继承，因为一些属性能继承的话，会使文档变得混乱，如border、margin、padding、background等框模型属性。你一定不想花功夫去清除继承的边框。  
>   >   >   继承的值根本没有特殊性，甚至连0特殊性都没有。理论上似乎不同，不过还是有差异的，如   
>   >   >   ``` html  
>   >   >   * {color:gray;}
>   >   >   h1#page-title{color:black;}
>   >   >   
>   >   >   <h1 id="page-title">Meerkat<em>Central</em></h1>
>   >   >   <p>Welcome</p>
>   >   >   ```  
>   >   >   这里的em继承h1#page-title选择器的声明color:black，但是其没有特殊值。而统配符选择器的特殊值为0,0,0,0。所以冲突时通配符的优先级更高。   
>   >   >   所以统配选择器往往有一种短路继承的效果，所以要避免不加区别地使用通配选择器。   
>   >   >* 层叠   
>   >   >   最重要的一个问题是，如果特殊性相等的两个规则应用到同一个元素会怎么样呢？  
>   >   >   除了按重要性!important和特殊性排序外，还有一个重要的点。按出现顺序 对应用到给定元素的所有声明排序。一个声明在样式表或文档中越后出现，它的权重就越大。如果样式表中有导入的样式表，一般认为出现在导入样式表中的声明在前，主样式表中的所有声明在后。
>   >   >   所以LVHA(:link、:visited、:hover、:active)使用这个顺序来编写伪类。
>4. 值和单位  
>   >* 数字  
>   >   CSS中有两类数字:整数和实数。这些数字类型主要作为其他值类型的基础，不过在某些情况下，这些基本类型数字也可以用作属性的值。在css2.1中实数定义为一个整数后可以跟有一个小数点和小数部分。如15.5、-270.004和5。
>   >* 百分数  
>   >   百分数值是一个计算得出的实数，其后跟有一个百分号。百分数值几乎总是相对于另一个值，这个值可以是任意的：可能是同一个元素另一个属性的值，也可以是从父元素继承的一个值，或者是祖先元素的一个值。接受百分数值的属性会对所允许的百分数值定义某些限制，还会定义百分数计算到什么程度。
>   >* 颜色  
>   >   使用HTML时有两种选择设置颜色，一是按名使用为数不多的几种颜色，如red和purple;或者使用16进制代码。
>   >   >1. 命名颜色  
>   >   >   如果你觉得从一个很小的基本颜色集中选择就足够了，那么最容易的办法就是使用你想要的颜色名。CSS称这些有名字的颜色为命名颜色。CSS2.1中定义了17个颜色名:
>   >   >   aqua    fuchsia     lime    olive   red     white  
>   >   >   black   gray        maroon  orange  silver  yellow  
>   >   >   blue    green       navy    purple  teal  
>   >   >2. 用RGB指定颜色  
>   >   >   计算机通过组合不同的红色，绿色和蓝色分量来创造颜色，这种组合通常称为RGB颜色。  
>   >   >   >* 函数式RGB颜色  
>   >   >   >   有两种颜色值类型使用函数式RGB记法而不是16进制记法。这种类型颜色值的一般语法是rgb(color),其中color用一个百分数或整数三元组表示。百分数值在0%-100%范围内，整数范围为0-255。  
>   >   >   >* 16进制RGB颜色  
>   >   >   >   CSS允许你使用HTML Web创作人员很熟悉的16进制颜色记法来定义颜色。  将三个介于00-FF的16进制数连起来，就可以设置一种颜色。这种记法的一般语法是#RRGGBB。  
>   >   >   >   在数学上等价于整数的三元组记法，如rgb(255,255,255)就完全等价于#FFFFFF。  
>   >   >   >* Web安全颜色  
>   >   >   >   所谓"web安全"颜色是指，在256色计算机系统上总能避免抖动的颜色。Web安全颜色可以表示为RGB值20%和51(0x33)的倍数。这样就有00、33、66、99、cc、FF总共6*6*6的216种安全颜色。抖动是指不同的平台有不同的调色板不同的浏览器也有自己的调色板。在选择特定的颜色时，浏览器会尽量使用本身所用的调色板中最接近的颜色。如果浏览器中没有所选的颜色就会通过抖动或混合自身的颜色来尝试重新产生该颜色。  
>   >* 长度单位  
>   >   很多CSS属性(如外边距)都依赖于长度度量来适当地显示各种页面元素。因此，CSS中有很多度量长度的方法。  
>   >   所有长度单位都可以表示为正数或负数，其后跟有一个标签(不过有些属性只接受正数)。另外还可以使用实数。长度单位可以划分为两类。  
>   >   >1. 绝对长度  
>   >   >   >   英寸(in)、厘米(cm)、毫米(mm)、点(pt)、派卡(pc)  
>   >   >2. 相对长度单位  
>   >   >   >   因为它们根据与其他事物的关系来度量。所度量的实际距离可能因为不在其控制之下的其他因素而改变，如屏幕分辨率、可视区的宽度，用户的首选项设置。共有三种相对长度单位：em、ex和px。  
>   >   >   >   1em定义为一种给定字体的font-size值。如果一个元素的font-size为14像素，那么对于该元素，1em就等于14像素。  
>   >   >   >   ex指所用字体中小写x的高度。因此，如果有两个段落，其中文本的大小为24点，但是各段使用了不同的字体，那么各段相应的ex值可能不同。  
>   >   >   >   从表面上来看，像素很直接。即一个显示器的屏幕像素，但是像素有一个缺点，如果按像素设置字体大小，那么ie7之前的用户无法使用浏览器中的文本大小来调整文本的大小。  
>   >* URL  
>   >   如果需要引用一个URL，一般格式为:
>   >   url(protocol://server/pathname)  
>   >   >* 绝对URL  
>   >   >   这里的绝对是指，不论这个URL放在哪里，它都能正常工作，因为它定义了web空间中的一个绝对位置。  
>   >   >* 相对URL  
>   >   >   它指定的是一个相对于该URL所在文档的位置。其格式一般为:  
>   >   >   url(pathname)  
>   >* 关键字  
>   >   有时一个值需要用某个词来描述，这种词就称为关键字。对此一个常见的例子就是关键字none，如果一个属性接受关键字，那么其关键字将只针对该属性的作用域定义。如果两个属性都使用同一个词作为关键字，那么这同一个关键字可能就有不同的行为。  
>   >   >* inherit关键字
>   >   >   css2.1中有一个关键字是所有属性共有的，就是inherit。inherit使一个属性的值与其父元素的值相同。在大多数情况下，不必指定继承。因为大多数属性本身会自然地继承。  
>5. 字体  
>   CSS试图为所有这些字体问题提供一些解决机制，不过它不能提供一个全面的解决方案。  
>   CSS字体处理中最复杂的部分是字体系列(font-family)匹配和字体加粗(font-weight)匹配，其次是字体大小(font-size)和字体风格(font-style)。
>   >* 字体系列  
>   >   特定字体系列和通用字体系列  
>   >   <table>
>   >       <thead>
>   >           <th>
>   >               <td>通用字体</td>
>   >               <td>说明</td>
>   >               <td>特定字体</td>
>   >           </th>
>   >           <tbody>
>   >               <tr>
>   >                   <td>Serif字体</td>
>   >                   <td>这些字体成比例,而且有上下短线。</td>
>   >                   <td>Times、Georgia、New Century Schoolbook</td>
>   >               </tr>
>   >               <tr>
>   >                   <td>Sans-serif字体</td>
>   >                   <td>字体成正比,没有上下短线</td>
>   >                   <td>Helvetica、Geneva、Verdana、Arial、Univers</td>
>   >               </tr>
>   >               <tr>
>   >                   <td>Monospace字体</td>
>   >                   <td>Monospace字体不是成比例的，可能有上下短线，可能没有。</td>
>   >                   <td>Courier、Courier New和Comic Sans</td>
>   >               </tr>
>   >               <tr>
>   >                   <td>Cursive字体</td>
>   >                   <td>这些字体试图模仿人的手写体。主要由曲线和serif字体中没有的笔画装饰组成。</td>
>   >                   <td>Zapf Chancery、Author、Comic Sans</td>
>   >               </tr>
>   >               <tr>
>   >                   <td>Fantasy字体</td>
>   >                   <td>这种字体无法用任何特征来定义</td>
>   >                   <td>Western、Woodblock、Klingon</td>
>   >               </tr>
>   >           </tbody>
>   >       </thead>
>   >   </table>
>   >   如:
>   >   body {font-family:sans-serif;}//设置通用的字体  
>   >   body {font-family:Georgia}//设置特定的字体  
>   >   body {font-family:Georgia,serif}//一个特定字体组合一个通用字体，在特定字体没有的时候就会选用候补字体。
>   >   body {font-family:Times,TimesNR,'New Century Schoolbook'}//这中是用多个特定字符组合。并且带有空格的字体名用单引号包裹。  
>   >   并且字体系列的声明是可以继承的。
>   >* 字体加粗  
>   >   利用font-weight属性，CSS允许对字体加粗有更多的控制。  
>   >   如:
>   >   h1{font-weight:bold}//进行字体加粗。  
>   >   h1{font-weight:100}//100-900的9个等级表示字体的粗细。  
>   >   h1{font-weight:bolder}//比父元素的weight大一级的最小等级。
>   >   h1{font-weight:lighter}//比父元素的weight小一级的最大等级。  
>   >* 字体大小  
>   >   font-size的作用是为给定字体的em框提供一个大小，该em框表示字体的所有大小小于该框。  
>   >   >* 绝对大小  
>   >   >   font-size有7个绝对大小值:xx-small、x-small、small、medium、large、x-large、xx-large  
>   >   >   这7个值得每一级间的缩放因子可能为1.5也可能为1.2。
>   >   >* 相对大小  
>   >   >   关键字larger和smaller很简单：大小相对于其父元素的大小在绝对大小梯度上移或下移。也不会限制在绝对大小范围内。  
>   >   >* 使用长度单位  
>   >   >   如:p{font-size:0.5in}等  
>   >* 风格和变形  
>   >   font-style和font-variant  
>   >   >* 有风格的字体  
>   >   >   font-style很简单:用于在normal文本、italic文本和oblique文本之间进行选择。  
>   >   >   如：p{font-style:italic;}
>   >   >* 字体变形  
>   >   >   除了大小和风格，字体还可以有变形。主要为small-caps小型大写字母。  
>   >* font属性  
>   >   font属性，涵盖所有其他字体属性(以及少数其他内容)的一个简写属性。如:  
>   >   font:[font-styel||font-variant||font-weight]?font-size[/line-height] font-family  
>   >   并且还有一些关键字设置font属性如：caption、icon、menu、message-box、small-caption、status-bar。这些都是系统字体。  
>   >* 字体匹配  
>   >   CSS允许匹配字体系列、加粗和变形。所有这些都使通过字体匹配完成的，这是一个相当复杂的过程。  
>   >   >1. 用户代理创建(或访问)一个字体属性数据库。这个数据库列出了用户代理能访问的所有字体的各种CSS属性。一般的，为机器上安装的所有字体和内置的字体。  
>   >   >2. 用户代理取得应用了字体属性的元素，并构建一个字体属性列表，其中列出显示该元素的必要字体属性。再根据font-style、font-variant、font-weight、font-size进行匹配。  
>   >   >3. 如果在第二步中未匹配任何字体，用户代理就会在这个字体系列中查找下一个候选的字体。如果找到了，则对该字体重复第二步。  
>   >   >4. 假设找到一个通用匹配，但是其中不包含显示给定元素所需的一切，重复第三步。  
>   >   >5. 最后，如果没有找到匹配，而且所有候选字体都已经试过了，则会为给定的通用字体系列选择默认字体。  
>   >   font-face规则  
>6. 文本属性  
>   文本和字体之间有什么不同？主要是，文本是内容，而字体用于显示这个内容。使用文本属性，可以控制文本相对于该行余下内容的位置，使其作为上标、加下划线，以及改变大小写等。  
>   >* 缩进和水平对齐  
>   >   >* 缩进文本  
>   >   >   有些网站在段落的第一个字母前放一个很小的透明图像，这些图像将文本推到后面来制造一种缩进文本的感觉。另外一些网站则使用完全非标砖的SPACER标记。在CSS中，有一种更好的方法实现文本缩进，即text-indent属性。如：
>   >   >   p{text-indent:3em}//会使所有p元素的首行缩进3em。  
>   >   >   一般地，可以为所有块级元素应用text-indent，但无法将这个属性应用到行内元素，图像之类的替换元素上也无法应用text-indent属性。  
>   >   >   text-indent还可以设置为负值。  
>   >   >   text-indent可以使用所有长度单位。百分数要相对于缩进元素父元素的宽度。  
>   >   >* 水平对齐  
>   >   >   与text-indent相比，text-align是一个更基本的属性，它会影响一个元素中的文本行相互之间的对其方式。  
>   >   >   值left、right、和center会导致元素中的文本分别左对齐、右对齐和居中。因为text-align只应用于块级元素，所以无法将行内的一个锚居中而不影响行中的其余部分。  
>   >   >   text-align:center和CENTER元素的作用一样，但实际上二者大不相同。CENTER不仅影响文本，还会把整个元素居中，如表。  
>   >   >   最后一个水平对齐属性是justify，在两端对齐文本中，文本行的左右两端都放在父元素的内边界上，然后调整单词和字母间的间隔，使各行的长度恰好相等。
>   >* 垂直对齐  
>   >   >* 行高  
>   >   >   line-height属性是指文本行基线之间的距离，而不是字体的大小，它确定了将各个元素框的高度增加或减少多少。通常，指定line-height可以用来增加文本行之间的垂直间隔，人们认为这是一种了解line-height如何工作的简单方法，但其实并不简单。line-height控制了行间距，这是文本行之间超出字体大小的额外空间。换句话说，line-height值和字体大小之差就是行间距。  
>   >   >* 构造文本行  
>   >   >   文本行中的每个元素都会生成一个内容区，这由字体的大小确定。这个内容区则会生成一个行内框，如果不存在其他因素，这个行内框就完全等于该元素的内容区。一旦给定内容行已经生成了所有行内框，接下来在行框的构造中就会考虑这些行内框。行框的高度恰好足以包含最高行内框的顶端和最低行内框的底端。  
>   >   >* 指定line-height值  
>   >   >   如果使用默认值normal，用户代理必须计算行间的垂直空间。通常是字体大小的1.2倍。其他的em、ex和百分数值都是相对于元素的font-size值计算的。  
>   >   >* 行高和继承  
>   >   >   line-height值从父元素继承时，要从父元素计算，而不是在子元素上计算。如:  
>   >   >   body{font-size:10px;}  
>   >   >   div{line-height:1em;}  
>   >   >   p{font-size:18px}//这样p继承div的line-height时为计算的值1em即10px；  
>   >   >   最好的解决办法是设置缩放因子，因为这个数会应用到该元素及其所有子元素，所以各元素会根据自己的font-size计算line-height。  
>   >   >   body{font-size:10px}  
>   >   >   div{line-height：1}  
>   >   >   p{font-size:18px}//继承父元素的因子1，所以此时的line-height为18px。  
>   >   >* 垂直对齐文本  
>   >   >   在CSS中，vertical-align属性只应用于行内元素和替换元素，如图像和表单输入元素。vertical-align属性不能继承。  
>   >   >   除了百分数值或长度值，该属性只接受8个关键字:baseline(默认值)、sub、super、bottom、text-bottom、middle、top、和text-top。  
>   >   >   >1. 基线对齐  
>   >   >   >   vertical-align:base-line要求一个元素的基线和其父元素的基线对齐。  
>   >   >   >2. 上标和下标  
>   >   >   >   vertical-align:sub声明会使一个元素变成下标，这意味着其基线相对于父元素的基线降低。而super则刚好与sub相反。  
>   >   >   >   注意sub和super不会改变元素的字体大小，所以需要自己用font-size调整大小。  
>   >   >   >3. 底端对齐  
>   >   >   >   vertical-align:bottom将元素行内框的底端与行框的底端对齐。而vertical-align:text-bottom表示行内文本的底端。替换元素或其他的非文本元素会忽略这个值。
>   >   >   >4. 顶端对齐  
>   >   >   >   vertical-align:top的效果与bottom刚好相反。元素的行内框的顶部和行框的顶部对齐。而text-top表示行内文本的顶部，替换元素或其他的非文本元素会忽略这个值。  
>   >   >   >5. 居中对齐  
>   >   >   >   middle,它往往应用于图像。middle会把行内元素框的中点与父元素基线上方0.5ex处的一个点对齐，这里的1ex相对于父元素的font-size定义。  
>   >   >   >6. 百分数  
>   >   >   >   将vertical-align设置一个百分数，会把元素的基线(或替换元素的底边)相对于父元素的基线升高或降低指定的量(相对于该元素line-height的百分数，而不是其父元素的line-height)。  
>   >   >   >7. 长度对齐  
>   >   >   >   如vertical-align：5px；会把一个元素与对齐前相比上升5像素。负长度会使元素下降。
>   >* 字间隔和字母间隔  
>   >   >* 字间隔  
>   >   >   word-spacing属性接受一个正长度值或负长度值。这个长度会增加到字之间的标准间隔。该值的normal与设置为0是一样的。  
>   >   >   如果提供一个正长度值，那么字之间的间隔就会增加。负值时，会把字拉近。  
>   >   >* 字母间隔  
>   >   >   letter-spacing属性的可取值包括所有长度。  
>   >   >* 间隔和对齐  
>   >   >   word-space的值可能受text-align属性值的影响。如果一个元素是两端对齐的，字母和字之间的空间可能会调整，以便文本在整行中刚好放下。如果为letter-spacing指定一个长度值，则不会受text-align影响，如果为normal字符间的间隔就可能改变。
>   >* 文本转换  
>   >   text-transform属性处理文本的大小写。  
>   >   默认值none对文本不做任何改动，将使用源文档中原有的大小写。uppercase和lowerccase将文本转换为全大写或全小写字符。而capitalize只对每个单词的首字母大写。
>   >* 文本装饰  
>   >   text-decoration属性。  
>   >   underline会添加下划线，overline会添加上划线，line-through则会画一个贯穿线，blink会让文本闪烁。
>   >* 文本阴影  
>   >   text-shadow：[color||length length length?]  
>   >   每个阴影都由一个颜色和3个长度值来定义。颜色设置阴影的颜色，前两个长度值确定了阴影与文本的偏移距离，第三个长度值可选，定义了阴影的“模糊半径”，模糊半径定义为从阴影轮廓到模糊效果边界的距离。  
>   >* 处理空白符  
>   >   white-space,它会影响用户代理对源文档中的空格、换行和tab字符的处理。  
>   >   <table>
>   >       <thead>
>   >           <th>
>   >               <td>值</td>
>   >               <td>空白符</td>
>   >               <td>换行符</td>
>   >               <td>自动换行</td>
>   >           </th>
>   >       </thead>
>   >       <tbody>
>   >           <tr>
>   >               <td>pre-line</td>
>   >               <td>合并</td>
>   >               <td>保留</td>
>   >               <td>允许</td>
>   >           </tr>
>   >           <tr>
>   >               <td>normal</td>
>   >               <td>合并</td>
>   >               <td>忽略</td>
>   >               <td>允许</td>
>   >           </tr>
>   >           <tr>
>   >               <td>nowrap</td>
>   >               <td>合并</td>
>   >               <td>忽略</td>
>   >               <td>不允许</td>
>   >           </tr>
>   >           <tr>
>   >               <td>pre</td>
>   >               <td>保留</td>
>   >               <td>保留</td>
>   >               <td>不允许</td>
>   >           </tr>
>   >           <tr>
>   >               <td>pre-wrap</td>
>   >               <td>保留</td>
>   >               <td>保留</td>
>   >               <td>允许</td>
>   >           </tr>
>   >       </tbody>
>   >   </table>
>7. 基本视觉格式化  
>   >* 基本框  
>   >   CSS假定每个元素都会生成一个或多个矩形框，这称为元素框。各元素框中心有一个内容区(content area)。周围有可选的内边距、边框和外边距。  
>   >   可以用多种属性设置各外边距、边框和内边距，如margin-left和border-bottom。内容的背景也会应用到内边距。外边距通常是透明的，从中可以看到父元素的背景。  
>   >   边框使用已定义样式生成，如solid和inset，边框的颜色使用border-color属性设置。  
>   >   >* 包含块  
>   >   >   每个元素都相对于其包含块摆放；可以这么说，包含块就是一个元素的"布局上下文"。  
>   >   >   对于文本流中的一个元素，包含块由最近的块级祖先框、表单元格或行内祖先框的内容边界构成。  
>   >   >* 快速复习  
>   >   >   >1. 正常流  
>   >   >   >   指西方语言文本从左向右，从上向下显示，这是熟悉的传统HTML文档的文本布局。  
>   >   >   >2. 非替换元素  
>   >   >   >   如果元素的内容包含在文档中，则称之为非替换元素。如段落元素。  
>   >   >   >3. 替换元素  
>   >   >   >   这是指用作为其他内容占位符的一个元素。如img元素和大多数表单元素。  
>   >   >   >4. 块级元素  
>   >   >   >   这是指段落、标题或div之类的元素。这些元素在正常流中时，会在其框之前和之后生成"换行",通过声明display：block,可以让元素生成块级框。  
>   >   >   >5. 行内元素  
>   >   >   >   这是指strong或span之类的元素。这些元素不会再之前或之后生成"行分隔符",它们是块级元素的后代，通过声明display:inline，可以让元素生成一个行内框3
>   >* 块级元素  
>   >   块级元素的框模型如下:  
>   >   <img src="./css权威指南-块级元素框模型">  
>   >   width一般定义为左内边界到右内边界的距离，height定义为上内边界到下内边界的距离。  
>   >   在大多数情况下，文档的高度和宽度由浏览器自动确定，这要基于可用的显示区域和其他一些因素。当然在CSS下，可以更加直接地控制元素的大小以及显示方式。  
>   >   >* 水平格式化  
>   >   >   水平格式化比较复杂，主要原因在于width影响的内容区的宽度，而不是整个可见的元素框。  
>   >   >   对此有一个简单的规则，正常流中块级元素框的水平部分总和就等于父元素的width。  
>   >   >   >* 水平属性  
>   >   >   >   水平属性的"7大属性"是:margin-left、border-left、padding-left、width、padding-right、border-right、margin-right。  
>   >   >   >   在这7个属性中，只有3个属性可以设置为auto:元素内容的width，以及左、右外边距。其余属性必须设置为特定的值，或者默认宽度0。  
>   >   >   >* 使用auto  
>   >   >   >   如果设置width、margin-left或margin-right中的某个值为auto，而余下两个属性指定为特定的值，那么设置为auto的属性会确定所需的长度，从而使元素框的宽度等于父元素的width。换句话说，假设7个属性的ehe必须等于400像素，没有设置内边距或边框，而且右外边距和width设置为100px，左外边距设置为auto，那么左外边距的宽度将是200px。  
>   >   >   >   如果这单个属性都设置为100px，即没有任何一个属性设置为auto会怎么样呢？  
>   >   >   >   这种3个属性都设置为非auto的某个值，叫做格式化属性过分受限(overconstrained),此时总会把margin-right强制为auto。  
>   >   >   >* 不只一个auto  
>   >   >   >   如果两个外边距都设置为auto，它们会设置为相等的长度，因此将元素在父元素中居中。  
>   >   >   >   如果一个外边距为auto，width为auto。这样会使auto的外边距为0，当送几个属性都为auto时，两个外边距都会设置为0，width会尽可能宽。  
>   >   >   >* 负外边距  
>   >   >   >   关键点是，7个水平属性的总和要等于父元素的width。所以如果当外边距为负数时，可能会使width变得很大来抵消负值。  
>   >   >   >   并且内边距，边框和内容宽度绝对不能为负值。  
>   >   >   >* 百分数  
>   >   >   >   如果width、内边距和外边距设置为百分数值，会应用同样的基本规则。值声明为长度还是百分数并不重要。  
>   >   >   >   边框的宽度不能是百分数，而只能是长度。
>   >   >   >* 替换元素-  
>   >   >   >   到目前为止，我们已经介绍了正常文本流中非替换块级元素的水平格式化。替换块级元素管理起来更简单一些。只有一个例外:如果width为auto，元素的宽度则是内容的固有宽度。但是可以为width指定一个特定值覆盖这个规则。
>   >   >* 垂直格式化  
>   >   >   一个元素的默认高度由其内容决定。高度还会受内容宽度的影响;段落越窄，相应地就越高，以便容纳其中所有的内联内容。  
>   >   >   在CSS中，可以对任何块级元素设置显示高度。如果这样做，其结果取决于另外一些因素。  
>   >   >   如果指定高度大于显示内容所需的高度,多余的高度会产生一个视觉效果，就好像有额外的内边距一样。  
>   >   >   如果指定高度小于显示内容所需的高度，浏览器会提供某种方法查看所有内容，而不是增加元素框的高度。浏览器可能会向元素增加一个滚动条。  
>   >   >   >* 垂直属性  
>   >   >   >   垂直格式化也有7个相关的属性:margin-top、border-top、padding-top、height、padding-bottom、border-bottom和margin-bottom。  
>   >   >   >   这7个属性的值必须等于元素包含块的height。这往往是块级元素父元素的height值。  
>   >   >   >   这7个属性中同样只有3个属性可以设置为auto:元素内容的height以及上下外边距。  
>   >   >   >   但是，如果正常流中一个块级元素的margin-top或margin-bottom设置为auto，它会自动计算为0。所以就不能很容易地将正常留元素在其包含快中垂直居中。  
>   >   >   >* 百分数高度  
>   >   >   >   如果一个块级正常流元素的height设置为一个百分数，这个值则是包含块height的一个百分数。  
>   >   >   >   如果没有显式声明包含块的height，百分数高度会重置为auto。  
>   >   >   >* auto高度  
>   >   >   >   在最简单的情况下，如果块级正常流元素设置为height:auto,显示时其高度将恰好足以包含其内联内容的行盒。  
>   >   >   >   如果块级正常流元素的高度设置为auto，而且只有块级子元素，其默认高度将是从最高块级子元素的外边框边界到最低级子元素外边框边界之间的距离。  
>   >   >   >   但是如果块级元素有上下内边距，或者上下边框，其高度则是从其最高子元素的上外边距边界到期最低子元素的下外边距边界之间的距离。  
>   >   >   >* 合并垂直外边距  
>   >   >   >   垂直格式化的另一个重要方面是垂直相邻外边距的合并。这种合并行为只应用于外边距。如果元素有内边距和边框，它们绝对不会合并。·  
>   >   >   >   比如一个无序列表，其列表项前后相邻，如果列表项作如下声明:  
>   >   >   >   li{margin-top:10px;margin-bottom:15px}  
>   >   >   >   每个列表项有10像素的上外边距和15像素的下外边距。但是在显示这个列表时，相邻列表项之间的距离是15像素，而不是25像素。   
>   >   >   >   如果相邻有多个外边距，也会出现合并，如列表的最后。  
>   >   >   >   ul{margin-bottom:15px;}
>   >   >   >   li{margin-top:10px;margin-bottom:20px;}
>   >   >   >   h1{margin-top:28px}
>   >   >   >   此时ul没有设置内边距和边框，所以其子元素li的外边距不会再ul中。所以三个外边距15px、20px、28px会进行合并，即为28px;  
>   >   >   >   如果给ul添加边框声明后，li的外边距就会在ul的内部，那么边框就是ul和h1的合并。  
>   >   >   >* 负外边距  
>   >   >   >   负外边距会影响外边距如何合并。如果垂直外边距都设置为负值，浏览器会取两个外边距绝对值的最大值。如果一个正外边距一个负外边距合并，则会从正外边距减去负外边距的绝对值。  
>   >   >   >   上下外边距为负时有一种"拉近"效果。与负水平外边距使元素超出其父元素没有什么区别。  
>   >   >   >   下面来考虑一个例子:  
>   >   >   >   li{margin-bottom：20px;}
>   >   >   >   ul{margin-bottom:-15px;}
>   >   >   >   h1{margin-top:-18px;}  
>   >   >   >   两个外边距中较大的一个增加到了最大的正外边距上(20px)得到了2px。  
>   >   >   >* 列表项  
>   >   >   >   列表项有自身的一些特殊规则。这些列表项前面通常有一个标志，如一个圆点或一个数字。这个标志实际上并不是列表项内容区的一部分。  
>   >   >   >   与一个列表项元素关联的标志可能在列表项内容之外，也可能处理为内容开始处的一个内联标志，这取决于属性list-style-position的值。
>   >* 行内元素  
>   >* 改变元素的显示