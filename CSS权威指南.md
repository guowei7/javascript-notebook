### <center>CSS权威指南笔记</center> ###
>1. CSS和文档  
>   层叠样式表(CSS)的功能非常强大，可以影响一个或一组文档的表现  
>   如果不存在某种文档，CSS基本上毫无用处。  
>   >* CSS的出现  
>   >   HTML只是作为一种结构化标记语言，用于描述文档的各个部分，而对于这些部分应当如何显示则很少谈及。但是随着网页的发展，就出现了一些样式上的需求，如文本的粗体和斜体等。  
>   >   迫于压力，就出现了一些FONT和BIG之类的标记元素。   
>   >   但是这样大量的使用没有任何含义的标记，会使文档的可用性降低。如搜索的困难，维护困难等。  
>   >* CSS作救星  
>   >   1. 丰富的样式  
>   >   >   CSS可以为任何元素的文本和背景设置颜色；允许在任何元素外围创建边框等。
>   >   2. 易于使用  
>   >   >   样式表将实现某些视觉效果的命令集中在一个方便的位置，而不是在文档中分散得到处都是。  
>   >   >   这样进行样式的统一修改和几个元素使用同一个样式都很方便。
>   >   3. 在多个页面上使用样式  
>   >   >   不仅能把一个页面的所有样式信息集中到一个位置，还可以创建一个样式表，然后把这个样式表应用到多个页面。既将样式表单独保存为一个文档，然后由要使用该文档的页面导入。  
>   >   4. 层叠  
>   >   >   CSS规定了冲突规则：这些规则统称为层叠。  
>   >* 元素  
>   >   元素是文档结构的基础。
>   >   1. 替换和非替换元素   
>   >   >* 替换元素  
>   >   >   替换元素是指用来替换元素内容的部分并非由文档内容直接表示。如img元素，这个标记不包含任何具体内容，只有一个元素名和一个属性。除非将其指向一个外部内容(这里就是src指向的图像),否则这个元素没有任何意义。input元素类似，取决于input的类型，要由一个单选框、复选框或文本输入框替换。  
>   >   >* 非替换元素  
>   >   >   大多数HTML和XHTML元素都是非替换元素。这意味着，其内容由用户代理(通常是一个浏览器)在元素本身生成的框中显示。如span元素。  
>   >   2. 元素显示角色  
>   >   >* 块级元素  
>   >   >   块级元素生成一个元素框，它会填充其父元素的内容区，傍边不能有其他元素。如p和div标签。  
>   >   >* 行内元素  
>   >   >   行内元素在一个文本行内生成元素框，而不会打断这行文本。行内元素最好的例子就是XHTML中的a元素。  
>   >   >   在HTML和XHTML中，块级元素不能继承自行内元素(即不能嵌套在行内元素中)。但是在CSS中显示角色如何嵌套不存在任何限制。如:
>   >   >   ``` html  
>   >   >   <body>
>   >   >       <p>This is a paragraph whit <em>an inline element</em> with in it.</p>
>   >   >   </body>
>   >   >   <!-- css没有这种限制，可以改变两个元素的显示角色-->
>   >   >   p{dispaly:inline}
>   >   >   em{display:block}
>   >   >   <body>
>   >   >       <!-- 这种行内元素中嵌套块级元素是不合法的-->
>   >   >       <em><p>This is a paragraph improperly enclosed by an inline element.</p></em>
>   >   >   </body>
>   >   >   
>   >   >   ```  
>   >* 结合CSS和XHTML  
>   >   CSS和文档关联的多种方式  
>   >   1. link标记  
>   >   >   其基本目的是允许HTML创作人员将包含link标记的文档与其他文档相关联。CSS使用这个标记来链接样式表和文档。  
>   >   >   为了成功地加载一个外部样式表，link必须放在head元素中，但不能放在其他元素内部。  
>   >   >   外部样式表只是一个规则列表，规则会保存到其自己的文件中。但是样式表中不能包含XHTML或任何其他标记语言，只能有样式规则。如果一个外部样式表中出现标记，会导致其中一部分或全部被忽略。
>   >   >* 属性
>   >   >   rel属性代表关系，一般关系为stylesheet。type属性为加载的数据类型，一般类型为text/css。这些设置后就可以确定浏览器如何处理其导入的数据。href属性是样式表的URL。最后是media属性，值all表示这个样式表要应用于所有表现媒体，另外得到最广泛支持的类型是all、screen和print，可以将多个媒体值组合在一起作为media的值。  
>   >   >* 候选样式表(alternate style sheet)  
>   >   >   将rel属性的值设置为alternate stylesheet，就可以定义候选样式表，只有在用户选择这个样式表时才会用于文档表现。并且如果浏览器支持候选样式表，那么浏览器就会根据link的title属性生成选择列表。 当没有title时就无法显示在列表中，同时可以设置相同的title值为候选样式表进行分组。 
>   >   2. style元素  
>   >   >   可以使用style元素包含样式表，它在文档中单独出现:  
>   >   >   ``` html 
>   >   >   <style type="text/css"></style>
>   >   >   ```
>   >   >   也可以为style元素添加media属性。  
>   >   >   style元素内添加的样式称为文档样式表或嵌套样式表，并且其中可能包含应用到文档的多个样式，还可以使用@import指令包含多个外部样式表链接。  
>   >   3. @import指令  
>   >   >   ``` html  
>   >   >   @import url(sheet.css) all;  
>   >   >   ```
>   >   >   不同于link标签每个@import都会使用，因为@import无法指定候选样式表。  
>   >   >   并且@import指令应该出现在样式表的开头，即应该出现在样式表的其他规则之前，否则会将其忽略掉。  
>   >   4. 内联样式  
>   >   >   如果只是想为单个元素指定一些样式，而不需要嵌套或外部样式表，就可以使用HTML的Style属性来设置一个内联样式(inline style)。  
>   >   >   除了在body外部出现的标记，style属性可以与任何其他HTML标记关联。  
>   >   >   style属性的值是一个声明块，而不能是整个样式表。  
>2. 选择器  
>   CSS的核心是能向文档中的一组元素类型应用某些规则。  
>   >* 规则的结构  
>   >   每个规则都由两个基本的部分:选择器(selector)和声明块(declaration block)。声明块由多个声明组成，每个声明则以一个属性-值对组成。每个样式表由多个规则组成。  
>   >   选择器:定义了将影响文档中的哪些部分。  
>   >   声明块:多个声明组合表示选择器对应的元素应该怎样显示。   
>   >* 元素选择器  
>   >   最常见的选择器往往是HTML元素，但也不完全是这样。也有可能是XML文档的样式。  
>   >   文档的元素就是最基本的选择器，在XML中可以创建新的标记，所以什么都有可能作为选择器。  
>   >* 声明和关键字  
>   >   声明的格式一般是一个属性名+":"+值+";"。几乎在所有的情况下，值要么是一个关键字，要么就是关键字的列表，关键字之间用空格分隔。   
>   >* 分组  
>   >   如果想为多个元素应用同一个样式怎么做呢  
>   >   >1. 选择器分组   
>   >   >   将两个选择器放在规则的左边并用一个逗号来分隔，这样就定义了一个规则，其右边的样式将应用到这两个选择器所引用的元素。  
>   >   >   通配选择器:使用"*"号表示选择器，这个选择器可以和任何元素匹配。  
>   >   >2. 声明分组  
>   >   >   将多个声明使用分号分隔放在同一个声明块中。  
>   >   >3. 选择器分组和声明分组结合  
>   >* 类选择器(class selector)和ID选择器(ID selector)  
>   >   可以以一种独立于文档元素的方式来指定样式，不过需要适当地标记文档后才能使用这些选择器。   
>   >   >1. 类选择器  
>   >   >   要应用样式而不考虑具体涉及的元素，最常用的方法就是使用类选择器。在使用类选择器之前需要使用class属性进行文档标记。  
>   >   >   *.warning{}//与通配选择器结合的类选择器，可以省略通配符"*"  
>   >   >   p.warning{}//与元素选择器结合的类选择器  
>   >   >   p.warning.help//是一个多类选择器，对应class="warning help"  
>   >   >2. ID选择器  
>   >   >   在某些方法，ID选择器类似于类选择器，不过也有一些重要的差别。ID选择器前面有一个#号。  
>   >   >   *#first-para{}//可以省略通配符。  
>   >   >   与类选择器不同，一个HTML文档中，ID选择器会使用一次，而且仅一次。并且ID选择器不能结合使用，因为ID属性不允许有以空格分隔的词列表。  
>   >   >   并且类选择器和ID选择器是区分大小写的，因为文档将类和ID值定义为区分大小写。  
>   >   >3. 属性选择器  
>   >   >   对于类选择器和ID选择器，你所做的只是选择属性值。但是在一些非HTML、SVG和MathML文档的标记语言中，不能使用这些类和ID选择器。所以CSS2引入了属性选择器(attribute selector)。它可以根据元素的属性及属性值来选择元素。
>   >   >   * 简单属性选择器  
>   >   >   >   只是选择有某个属性的元素，而不论该属性的值是什么，可以使用一个简单属性选择器。如：
>   >   >   >   h1[class]{}//有class属性(值不限)的所有h1元素。
>   >   >   >   *[title]{}//所有带有title属性的元素  
>   >   >   >   a[href][title]//所有带有href和title属性的a元素  
>   >   >   * 具体属性值选择  
>   >   >   >   除了选择有某些属性的元素，还可以进一步缩小选择范围，只选择有特定属性值的元素。  
>   >   >   >   a[href="http://XXX.com"]{}//href属性值为http://XXX.com的a元素。  
>   >   >   >   也可以多个联合使用，另外这个值的匹配是完全匹配。  
>   >   >   * 根据部分属性值选择
>   >   >   >   [foo~="bar"]//选择属性值中包含独立单词bar的所有元素  
>   >   >   >   [foo^="bar"]//选择属性值以"bar"结尾的所有元素  
>   >   >   >   [foo$="bar"]//选择属性值以"bar"开头的所有元素  
>   >   >   >   [foo*="bar"]//选择属性值中包含子串"bar"的所有元素  
>   >   >   * 特性属性选择类型  
>   >   >   >   [lang|=en]//选择lang属性为"en"或"en-"开头的所有元素。单词完成或以"-"分隔。  
>   >   >4. 后代选择器(descendant selector)  
>   >   >   后代选择器也称为包含选择器或上下文选择器。定义后代选择器就是来创建一些规则，它们仅在某些结构中其作用，而在另外一些结构中不起作用。如:
>   >   >   h1 em{}//只对h1的后代em元素应用样式  
>   >   >   在一个后代选择器中，规则左边的选择器一端包括两个或多个用空格分隔的选择器。  
>   >   >5. 选择子元素  
>   >   >   在某些情况下，可能并不想选择一个任意的后代元素；而是希望缩小范围，只选择另一个元素的子元素。例如：
>   >   >   h1>strong{}//>为子结合符，表示h1元素子元素的strong元素。  
>   >   >6. 选择相邻兄弟元素  
>   >   >   假设你希望对一个标题后紧接着的段落应用样式，或者像一个段落后紧接着的列表指定特殊的外边距。要选择紧接在另一个元素后的元素，而且两者有相同的父元素，可以使用相邻兄弟结合符(adjacentsibling combinator),这表示为一个(+)号。如：  
>   >   >   h1 + p {}//选择h1元素所有的p兄弟元素。  
>   >   >   并且CSS要求两个元素按"源顺序"出现。  
>   >   >7. 伪类和伪元素  
>   >   >   利用这些选择器，可以为文档中不一定具体存在的结构指定样式，或者为某些元素的状态所指示的幻想类指定样式。  
>   >   >   * 伪类选择器  
>   >   >   >   如锚元素有两个类型，已访问和未访问的。这些类型称为伪类(pseudo-class)，使用这些伪类的选择器称为伪类选择器。如:
>   >   >   >   a:visited{}//已访问的锚元素
>   >   >   >* 链接伪类  
>   >   >   >   a:link{}//选择未访问的有href属性的a元素  
>   >   >   >   a:visited{}//选择已访问的a元素  
>   >   >   >* 动态伪类  
>   >   >   >   link和visited两个是静态伪类，即第一次显示之后，它们一般不会再改变文档的样式。  
>   >   >   >   还有一些可以根据用户行为改变文档外观的伪类，主要有下面三种动态伪类:  
>   >   >   >   :focus//指示当前拥有输入焦点的元素。  
>   >   >   >   :hover//指示鼠标指针停留在哪个元素上。  
>   >   >   >   :active//指示被用户输入激活的元素。  
>   >   >   >   input:focus{}//为拥有输入焦点的input元素设置样式  
>   >   >   >* 选择第一个子元素  
>   >   >   >   还可以使用另一个静态伪类:first-child来选择元素的第一个子元素。  
>   >   >   >   p:first-child{}//选择所有作为第一个子元素的p元素。  
>   >   >   >   并不是选择p元素的第一个子元素，因为伪类的实质是把某种幻想类关联到与伪类相关的元素。  
>   >   >   >* 根据语言选择  
>   >   >   >   有些情况下，你可能想根据元素的语言来选择。则可以使用:lang伪类，从对应模式来讲，:lang伪类就像|=属性选择器。  
>   >   >   >* 结合伪类  
>   >   >   >   a:link:hover{}//鼠标停留在未访问的超链接上时，两个换前后顺序也没有影响  
>   >   >   >   a:visited:hover{}//鼠标停留在已访问的超链接上时。  
>   >   >   >   但是不能将互斥的伪类进行结合，如a:link:visited。一般都会被忽略。  
>   >   >* 伪元素选择器  
>   >   >   就像伪类为锚指定幻想类一样，伪元素能够在文档中插入假象的元素，从而得到某种效果。  
>   >   >   CSS2.1中定义了4个伪元素:设置首字母样式、设置第一行样式、设置之前和之后的样式。  
>   >   >   >* 设置首字母样式  
>   >   >   >   用于设置一个块级元素首字母的样式，而且仅对该首字母设置样式。  
>   >   >   >   p:first-letter{}//将每个p元素的第一个字母设置样式。  
>   >   >   >   其假想的元素如下:
>   >   >   >   ``` html  
>   >   >   >   <p><p:first-letter>T</p:first-letter>his is an p element</p>  
>   >   >   >   ```  
>   >   >   >* 设置第一行的样式  
>   >   >   >   p:first-line{}//可以用来影响元素中第一个文本行。  
>   >   >   >   对于:first-letter和:first-line伪元素只能应用于标记或段落之类的块级元素，而不能应用于超链接等行内元素。后来在CSS2.1中:first-letter能应用到所有元素。但是两者的CSS属性还是有一些限制。并且所有伪元素应该放在选择器的最后面。  
>   >   >   >* 设置之前和之后元素的样式  
>   >   >   >   h2:before{content:"}}";color:silver}//在每个h2元素前添加内容  
>   >   >   >   h2:after{content:"}}";color:silver}//在每个h2元素后面添加内容  
>3. 结构和层叠  
>   >   有了结构树，选择器才能起作用，这也是CSS另一个重要方面(继承)的核心。  
>   >   继承是从一个元素向其后代元素传递属性值所采用的机制。确定应当向一个元素应用哪些值时，用户代理不仅要考虑继承，还要考虑声明的特殊性，另外需要考虑声明本身的来源。这个过程就是层叠。  
>   >   >* 特殊性  
>   >   >   之前介绍了多种不同的方法选择元素。所以可能同一个元素可以使用两个或多个规则来选择，每个规则都有其自己的选择器。如:  
>   >   >   h1 {color:red}
>   >   >   body h1{color:green}
>   >   >   
>   >   >   h2.grape{color:purple}
>   >   >   h2{color:silver}
>   >   >   
>   >   >   html>body table tr[id="totals"] td ul>li{color:maroon;}
>   >   >   li#answer{color:navy;}
>   >   >   对于这三对规则，每一对规则肯定只能有一个规则胜出，那么哪一个规则更强呢？  
>   >   >   这时就在于每个选择器的特殊性，对于每个规则，用户代理会计算选择器的特殊性，并将这个特殊性附加到规则中的各个声明。如果有元素存在冲突的属性声明，那么有最高特殊性的声明就会胜出。  
>   >   >   特殊性值表述为4个部分，如:0,0,0,0。具体如下：
>   >   >   <ul>
>   >   >       <li>对于选择器中给定的各个ID属性值，加0,1,0,0</li>
>   >   >       <li>对于选择器中给定的各个类属性值、属性选择或伪类，加0,0,1,0</li>
>   >   >       <li>对于选择器中给定的各个元素和伪元素，加0,0,0,1</li>
>   >   >       <li>结合符和通配选择器对特殊性没有贡献</li>
>   >   >   </ul>  
>   >   >* 声明和特殊性  
>   >   >   一旦确定一个选择器的特殊性，这个值将授予其所有相关声明。  
>   >   >* 通配选择器特殊性  
>   >   >   通配选择器对一个选择器的特殊性没有贡献。其特殊性为0,0,0,0，这与根本没有特殊性有区别。   
>   >   >   而结合符则根本没有特殊性，甚至连0特殊性都没有。  
>   >   >* ID和属性选择器的特殊性    
>   >   >   因为ID选择器和属性选择器对特殊性的贡献分别为0,1,0,0和0,0,1,0。所以如下:
>   >   >   #meadow{}//0,1,0,0   
>   >   >   *[id="meadow"]{}//0,0,1,0  
>   >   >   尽管都是选择ID为meadow的元素，然而其特殊性不相同。  
>   >   >* 内联样式特殊性       
>   >   >   之前见过的特殊性都是以0开头的特殊性，一般，第一个0是为内联样式声明保留的，它比所有其他声明的特殊性都高，为1,0,0,0。  
>   >   >* 重要性    
>   >   >   有时某个声明可能非常重要，超过了所有其他声明。CSS2.1称之为重要声明，并允许 在这些声明的结束分号之前插入!important来标志。如：
>   >   >   p.light{color:yellow;font:smaller Times,serif !important}    
>   >   >   重要声明和非重要声明要分开考虑，重要声明的特殊性冲突会在重要声明内部解决，而不会与非重要声明混淆。但是一个重要声明和一个非重要声明冲突，胜出的总是重要声明。